{"ast":null,"code":"// src/utils/api.js\n// Base de API:\n// - En dev usa \"/api\" y CRA proxy lo manda a :4000.\n// - En prod también \"/api\" y Nginx lo reenvía al backend.\n// - Puedes forzar con REACT_APP_API_BASE o REACT_APP_BACKEND_URL.\nexport const API_BASE = (process.env.REACT_APP_API_BASE || process.env.REACT_APP_BACKEND_URL || \"/api\").trim();\n\n// Construye URL (acepta rutas absolutas http/https)\nexport const apiUrl = (path = \"\") => {\n  if (/^https?:\\/\\//i.test(path)) return path;\n  const base = API_BASE.endsWith(\"/\") ? API_BASE.slice(0, -1) : API_BASE;\n  const p = String(path).startsWith(\"/\") ? path : `/${path}`;\n  return `${base}${p}`;\n};\nconst isFormData = body => typeof FormData !== \"undefined\" && body instanceof FormData;\n\n// Wrapper básico de fetch con:\n// - Header Content-Type automático (excepto FormData)\n// - Bearer token automático (puedes desactivar con { withAuth: false })\n// - Timeout (por defecto 20s, cambia con { timeoutMs })\nexport async function apiFetch(path, options = {}) {\n  var _options$timeoutMs;\n  const url = apiUrl(path);\n  const headers = new Headers(options.headers || {});\n  const withAuth = options.withAuth !== false;\n\n  // Content-Type automático salvo FormData o si ya está definido\n  if (!isFormData(options.body) && !headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json\");\n  }\n\n  // Token automático si existe y no está seteado\n  if (withAuth && !headers.has(\"Authorization\")) {\n    const token = typeof localStorage !== \"undefined\" && localStorage.getItem(\"token\");\n    if (token) headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n  const controller = new AbortController();\n  const timeoutMs = Number((_options$timeoutMs = options.timeoutMs) !== null && _options$timeoutMs !== void 0 ? _options$timeoutMs : 20000);\n  const timeoutId = setTimeout(() => controller.abort(\"timeout\"), timeoutMs);\n  try {\n    const res = await fetch(url, {\n      ...options,\n      headers,\n      signal: controller.signal\n    });\n    return res;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// Parseo seguro de JSON (si no es JSON retorna texto)\nasync function parseJsonSafe(res) {\n  const text = await res.text();\n  try {\n    return JSON.parse(text);\n  } catch {\n    return text;\n  }\n}\n\n// Helpers de conveniencia que DEVUELVEN el cuerpo ya parseado (o lanzan error con mensaje)\nexport async function apiGet(path, opts) {\n  const res = await apiFetch(path, {\n    ...opts,\n    method: \"GET\"\n  });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : (data === null || data === void 0 ? void 0 : data.message) || `HTTP ${res.status}`);\n  return data;\n}\nexport async function apiPost(path, body, opts = {}) {\n  const isFD = isFormData(body);\n  const res = await apiFetch(path, {\n    ...opts,\n    method: \"POST\",\n    body: isFD ? body : JSON.stringify(body !== null && body !== void 0 ? body : {}),\n    // si es FormData, no forzar Content-Type (lo hace el browser)\n    headers: isFD ? opts.headers : opts.headers\n  });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : (data === null || data === void 0 ? void 0 : data.message) || `HTTP ${res.status}`);\n  return data;\n}\nexport async function apiPut(path, body, opts = {}) {\n  const isFD = isFormData(body);\n  const res = await apiFetch(path, {\n    ...opts,\n    method: \"PUT\",\n    body: isFD ? body : JSON.stringify(body !== null && body !== void 0 ? body : {}),\n    headers: isFD ? opts.headers : opts.headers\n  });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : (data === null || data === void 0 ? void 0 : data.message) || `HTTP ${res.status}`);\n  return data;\n}\nexport async function apiDelete(path, opts) {\n  const res = await apiFetch(path, {\n    ...opts,\n    method: \"DELETE\"\n  });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : (data === null || data === void 0 ? void 0 : data.message) || `HTTP ${res.status}`);\n  return data;\n}","map":{"version":3,"names":["API_BASE","process","env","REACT_APP_API_BASE","REACT_APP_BACKEND_URL","trim","apiUrl","path","test","base","endsWith","slice","p","String","startsWith","isFormData","body","FormData","apiFetch","options","_options$timeoutMs","url","headers","Headers","withAuth","has","set","token","localStorage","getItem","controller","AbortController","timeoutMs","Number","timeoutId","setTimeout","abort","res","fetch","signal","clearTimeout","parseJsonSafe","text","JSON","parse","apiGet","opts","method","data","ok","Error","status","message","apiPost","isFD","stringify","apiPut","apiDelete"],"sources":["/Users/reyvipo/Documents/GitHub/titilab/frontend/src/utils/api.js"],"sourcesContent":["// src/utils/api.js\n// Base de API:\n// - En dev usa \"/api\" y CRA proxy lo manda a :4000.\n// - En prod también \"/api\" y Nginx lo reenvía al backend.\n// - Puedes forzar con REACT_APP_API_BASE o REACT_APP_BACKEND_URL.\nexport const API_BASE =\n  (process.env.REACT_APP_API_BASE || process.env.REACT_APP_BACKEND_URL || \"/api\").trim();\n\n// Construye URL (acepta rutas absolutas http/https)\nexport const apiUrl = (path = \"\") => {\n  if (/^https?:\\/\\//i.test(path)) return path;\n  const base = API_BASE.endsWith(\"/\") ? API_BASE.slice(0, -1) : API_BASE;\n  const p = String(path).startsWith(\"/\") ? path : `/${path}`;\n  return `${base}${p}`;\n};\n\nconst isFormData = (body) =>\n  typeof FormData !== \"undefined\" && body instanceof FormData;\n\n// Wrapper básico de fetch con:\n// - Header Content-Type automático (excepto FormData)\n// - Bearer token automático (puedes desactivar con { withAuth: false })\n// - Timeout (por defecto 20s, cambia con { timeoutMs })\nexport async function apiFetch(path, options = {}) {\n  const url = apiUrl(path);\n  const headers = new Headers(options.headers || {});\n  const withAuth = options.withAuth !== false;\n\n  // Content-Type automático salvo FormData o si ya está definido\n  if (!isFormData(options.body) && !headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json\");\n  }\n\n  // Token automático si existe y no está seteado\n  if (withAuth && !headers.has(\"Authorization\")) {\n    const token = typeof localStorage !== \"undefined\" && localStorage.getItem(\"token\");\n    if (token) headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n\n  const controller = new AbortController();\n  const timeoutMs = Number(options.timeoutMs ?? 20000);\n  const timeoutId = setTimeout(() => controller.abort(\"timeout\"), timeoutMs);\n\n  try {\n    const res = await fetch(url, {\n      ...options,\n      headers,\n      signal: controller.signal,\n    });\n    return res;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// Parseo seguro de JSON (si no es JSON retorna texto)\nasync function parseJsonSafe(res) {\n  const text = await res.text();\n  try {\n    return JSON.parse(text);\n  } catch {\n    return text;\n  }\n}\n\n// Helpers de conveniencia que DEVUELVEN el cuerpo ya parseado (o lanzan error con mensaje)\nexport async function apiGet(path, opts) {\n  const res = await apiFetch(path, { ...opts, method: \"GET\" });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : data?.message || `HTTP ${res.status}`);\n  return data;\n}\n\nexport async function apiPost(path, body, opts = {}) {\n  const isFD = isFormData(body);\n  const res = await apiFetch(path, {\n    ...opts,\n    method: \"POST\",\n    body: isFD ? body : JSON.stringify(body ?? {}),\n    // si es FormData, no forzar Content-Type (lo hace el browser)\n    headers: isFD ? opts.headers : opts.headers,\n  });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : data?.message || `HTTP ${res.status}`);\n  return data;\n}\n\nexport async function apiPut(path, body, opts = {}) {\n  const isFD = isFormData(body);\n  const res = await apiFetch(path, {\n    ...opts,\n    method: \"PUT\",\n    body: isFD ? body : JSON.stringify(body ?? {}),\n    headers: isFD ? opts.headers : opts.headers,\n  });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : data?.message || `HTTP ${res.status}`);\n  return data;\n}\n\nexport async function apiDelete(path, opts) {\n  const res = await apiFetch(path, { ...opts, method: \"DELETE\" });\n  const data = await parseJsonSafe(res);\n  if (!res.ok) throw new Error(typeof data === \"string\" ? `HTTP ${res.status}: ${data}` : data?.message || `HTTP ${res.status}`);\n  return data;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}